<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>배열 및 객체 메서드 표</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            font-weight: bold;
            padding: 20px;
            display: flex;
            justify-content: space-around;

        }

        h1 {
            display: block;
            justify-self: center;
        }

        table {
            border-collapse: collapse;
            width: 800px;
            margin: 0 auto 0 auto;
            font-size: 14px;
        }

        th,
        td {
            border: 1px solid #333;
            padding: 8px;
            text-align: center;
        }

        th {
            background-color: #f0f0f0;
        }

        .download-btn {
            margin: 20px 0;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div>
        <h1>배열 메서드</h1>
        <table id="arrayMethods">
            <thead>
                <tr>
                    <th>메서드</th>
                    <th>호출 방식</th>
                    <th>매개변수 설명</th>
                    <th>원본 변경 여부 및 반환값</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>push</td>
                    <td>arr.push(...items)</td>
                    <td>items: 배열 끝에 추가할 요소들</td>
                    <td>원본 배열 변경; 반환: 배열의 길이</td>
                </tr>
                <tr>
                    <td>pop</td>
                    <td>arr.pop()</td>
                    <td>없음 (배열의 마지막 요소 제거)</td>
                    <td>원본 배열 변경; 반환: 제거한 요소</td>
                </tr>
                <tr>
                    <td>shift</td>
                    <td>arr.shift()</td>
                    <td>없음 (배열의 첫 요소 제거)</td>
                    <td>원본 배열 변경; 반환: 제거한 요소</td>
                </tr>
                <tr>
                    <td>unshift</td>
                    <td>arr.unshift(...items)</td>
                    <td>items: 배열 앞에 추가할 요소들</td>
                    <td>원본 배열 변경; 반환: 배열의 길이</td>
                </tr>
                <tr>
                    <td>splice</td>
                    <td>arr.splice(start, deleteCount, ...items)</td>
                    <td>
                        start: 변경 시작 인덱스<br>
                        deleteCount: 제거할 요소 개수<br>
                        items: 추가할 요소들
                    </td>
                    <td>원본 배열 변경; 반환: 제거된 요소들의 배열</td>
                </tr>
                <tr>
                    <td>slice</td>
                    <td>arr.slice(start, end)</td>
                    <td>
                        start: 추출 시작 인덱스<br>
                        end: 추출 종료 인덱스 (미포함)
                    </td>
                    <td>원본 배열 변경 없음; 반환: 새로운 배열</td>
                </tr>
                <tr>
                    <td>concat</td>
                    <td>arr.concat(...arrays)</td>
                    <td>arrays: 연결할 배열 또는 값들</td>
                    <td>원본 배열 변경 없음; 반환: 새로운 배열</td>
                </tr>
                <tr>
                    <td>map</td>
                    <td>arr.map(callback, thisArg)</td>
                    <td>
                        callback: 각 요소에 대해 호출될 함수<br>
                        thisArg: callback 실행 시 this로 사용할 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: 새로운 배열</td>
                </tr>
                <tr>
                    <td>filter</td>
                    <td>arr.filter(callback, thisArg)</td>
                    <td>
                        callback: 조건에 맞는 요소 선택 함수<br>
                        thisArg: callback 실행 시 this로 사용할 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: 새로운 배열</td>
                </tr>
                <tr>
                    <td>reduce</td>
                    <td>arr.reduce(callback, initialValue)</td>
                    <td>
                        callback: 누적 계산 함수<br>
                        initialValue: 초기 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: 단일 누적 값</td>
                </tr>
                <tr>
                    <td>reduceRight</td>
                    <td>arr.reduceRight(callback, initialValue)</td>
                    <td>
                        callback: 오른쪽에서 왼쪽 누적 계산 함수<br>
                        initialValue: 초기 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: 단일 누적 값</td>
                </tr>
                <tr>
                    <td>forEach</td>
                    <td>arr.forEach(callback, thisArg)</td>
                    <td>
                        callback: 각 요소에 대해 호출될 함수<br>
                        thisArg: callback 실행 시 this로 사용할 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: undefined</td>
                </tr>
                <tr>
                    <td>find</td>
                    <td>arr.find(callback, thisArg)</td>
                    <td>
                        callback: 조건을 만족하는 첫 요소 찾기 함수<br>
                        thisArg: callback 실행 시 this로 사용할 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: 첫 조건 만족 요소 또는 undefined</td>
                </tr>
                <tr>
                    <td>findIndex</td>
                    <td>arr.findIndex(callback, thisArg)</td>
                    <td>
                        callback: 조건을 만족하는 요소의 인덱스 찾는 함수<br>
                        thisArg: callback 실행 시 this로 사용할 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: 인덱스 또는 -1</td>
                </tr>
                <tr>
                    <td>some</td>
                    <td>arr.some(callback, thisArg)</td>
                    <td>
                        callback: 조건 만족 여부 확인 함수<br>
                        thisArg: callback 실행 시 this로 사용할 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: true 또는 false</td>
                </tr>
                <tr>
                    <td>every</td>
                    <td>arr.every(callback, thisArg)</td>
                    <td>
                        callback: 모든 요소가 조건 만족 여부 함수<br>
                        thisArg: callback 실행 시 this로 사용할 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: true 또는 false</td>
                </tr>
                <tr>
                    <td>sort</td>
                    <td>arr.sort(compareFunction)</td>
                    <td>compareFunction: 두 요소 비교 함수 (생략 시 기본 문자열 비교)</td>
                    <td>원본 배열 변경 (제자리 정렬); 반환: 정렬된 배열(원본)</td>
                </tr>
                <tr>
                    <td>reverse</td>
                    <td>arr.reverse()</td>
                    <td>없음 (배열 순서 반전)</td>
                    <td>원본 배열 변경; 반환: 반전된 배열(원본)</td>
                </tr>
                <tr>
                    <td>includes</td>
                    <td>arr.includes(valueToFind, fromIndex)</td>
                    <td>
                        valueToFind: 찾을 값<br>
                        fromIndex: 검색 시작 인덱스
                    </td>
                    <td>원본 배열 변경 없음; 반환: true 또는 false</td>
                </tr>
                <tr>
                    <td>indexOf</td>
                    <td>arr.indexOf(searchElement, fromIndex)</td>
                    <td>
                        searchElement: 검색 요소<br>
                        fromIndex: 시작 인덱스
                    </td>
                    <td>원본 배열 변경 없음; 반환: 인덱스 또는 -1</td>
                </tr>
                <tr>
                    <td>lastIndexOf</td>
                    <td>arr.lastIndexOf(searchElement, fromIndex)</td>
                    <td>
                        searchElement: 검색 요소<br>
                        fromIndex: 시작 인덱스 (뒤에서부터 검색)
                    </td>
                    <td>원본 배열 변경 없음; 반환: 인덱스 또는 -1</td>
                </tr>
                <tr>
                    <td>join</td>
                    <td>arr.join(separator)</td>
                    <td>separator: 각 요소 구분 문자열 (생략 시 콤마)</td>
                    <td>원본 배열 변경 없음; 반환: 결합된 문자열</td>
                </tr>
                <tr>
                    <td>flat</td>
                    <td>arr.flat(depth)</td>
                    <td>depth: 평탄화 깊이 (기본값 1)</td>
                    <td>원본 배열 변경 없음; 반환: 평탄화된 새로운 배열</td>
                </tr>
                <tr>
                    <td>flatMap</td>
                    <td>arr.flatMap(callback, thisArg)</td>
                    <td>
                        callback: 각 요소 처리 함수<br>
                        thisArg: callback 실행 시 this로 사용할 값
                    </td>
                    <td>원본 배열 변경 없음; 반환: 평탄화된 새로운 배열</td>
                </tr>
                <tr>
                    <td>copyWithin</td>
                    <td>arr.copyWithin(target, start, end)</td>
                    <td>
                        target: 복사할 위치 인덱스<br>
                        start: 복사 시작 인덱스<br>
                        end: 복사 종료 인덱스 (미포함)
                    </td>
                    <td>원본 배열 변경 (제자리 복사); 반환: 변경된 배열(원본)</td>
                </tr>
                <tr>
                    <td>fill</td>
                    <td>arr.fill(value, start, end)</td>
                    <td>
                        value: 채울 값<br>
                        start: 채우기 시작 인덱스<br>
                        end: 채우기 종료 인덱스 (미포함)
                    </td>
                    <td>원본 배열 변경; 반환: 변경된 배열(원본)</td>
                </tr>
            </tbody>
        </table>
    </div>
    <div>
        <h1>객체 메서드</h1>
        <table id="objectMethods">
            <thead>
                <tr>
                    <th>메서드</th>
                    <th>호출 방식</th>
                    <th>매개변수 설명</th>
                    <th>원본 변경 여부 및 반환값</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Object.keys</td>
                    <td>Object.keys(obj)</td>
                    <td>obj: 키를 추출할 객체</td>
                    <td>원본 객체 변경 없음; 반환: 키 배열</td>
                </tr>
                <tr>
                    <td>Object.values</td>
                    <td>Object.values(obj)</td>
                    <td>obj: 값을 추출할 객체</td>
                    <td>원본 객체 변경 없음; 반환: 값 배열</td>
                </tr>
                <tr>
                    <td>Object.entries</td>
                    <td>Object.entries(obj)</td>
                    <td>obj: 키-값 쌍으로 변환할 객체</td>
                    <td>원본 객체 변경 없음; 반환: [key, value] 배열</td>
                </tr>
                <tr>
                    <td>Object.fromEntries</td>
                    <td>Object.fromEntries(iterable)</td>
                    <td>iterable: [key, value] 배열 또는 이터러블</td>
                    <td>원본과 무관; 반환: 새 객체</td>
                </tr>
                <tr>
                    <td>Object.assign</td>
                    <td>Object.assign(target, ...sources)</td>
                    <td>
                        target: 병합 대상 객체<br>
                        sources: 병합할 객체들
                    </td>
                    <td>target 변경; 반환: 수정된 target 객체</td>
                </tr>
                <tr>
                    <td>Object.create</td>
                    <td>Object.create(proto, propertiesObject)</td>
                    <td>
                        proto: 새 객체의 프로토타입<br>
                        propertiesObject: (선택) 속성 서술자
                    </td>
                    <td>원본과 무관; 반환: 새 객체</td>
                </tr>
                <tr>
                    <td>Object.defineProperty</td>
                    <td>Object.defineProperty(obj, property, descriptor)</td>
                    <td>
                        obj: 속성 정의할 객체<br>
                        property: 속성 이름<br>
                        descriptor: 속성 서술자
                    </td>
                    <td>obj 변경; 반환: obj</td>
                </tr>
                <tr>
                    <td>Object.defineProperties</td>
                    <td>Object.defineProperties(obj, props)</td>
                    <td>
                        obj: 속성 정의할 객체<br>
                        props: 속성 서술자 객체
                    </td>
                    <td>obj 변경; 반환: obj</td>
                </tr>
                <tr>
                    <td>Object.freeze</td>
                    <td>Object.freeze(obj)</td>
                    <td>obj: 동결할 객체</td>
                    <td>원본 객체 변경(변경 불가); 반환: 동결된 객체</td>
                </tr>
                <tr>
                    <td>Object.seal</td>
                    <td>Object.seal(obj)</td>
                    <td>obj: 밀봉할 객체</td>
                    <td>원본 객체 변경(새 속성 추가 불가); 반환: 밀봉된 객체</td>
                </tr>
                <tr>
                    <td>JSON.stringify</td>
                    <td>JSON.stringify(value, replacer, space)</td>
                    <td>
                        value: 변환할 값<br>
                        replacer: 선택적 함수 또는 배열<br>
                        space: 가독성 위한 들여쓰기
                    </td>
                    <td>원본 변경 없음; 반환: JSON 문자열</td>
                </tr>
                <tr>
                    <td>JSON.parse</td>
                    <td>JSON.parse(text, reviver)</td>
                    <td>
                        text: JSON 문자열<br>
                        reviver: 선택적 함수
                    </td>
                    <td>원본 변경 없음; 반환: 새 객체 또는 값</td>
                </tr>
            </tbody>
        </table>
        <button id="downloadBtn" class="download-btn">이미지로 다운로드</button>
    </div>
    

    <!-- html2canvas 라이브러리 (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        const downloadBtn = document.getElementById('downloadBtn');
        downloadBtn.addEventListener('click', () => {
            // 전체 페이지를 캡처하려면 document.body를, 특정 표만 캡처하려면 해당 요소의 id를 사용하세요.
            html2canvas(document.body).then(canvas => {
                const link = document.createElement('a');
                link.download = 'methods-table.png';
                link.href = canvas.toDataURL();
                link.click();
            });
        });
    </script>
</body>

</html>